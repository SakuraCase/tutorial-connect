package main

import (
	"context"
	"log"
	"net/http"

	"example/gen/greet/v1/greetv1connect" // generated by protoc-gen-connect-go
	"example/service"

	"connectrpc.com/connect"
	"github.com/rs/cors"
)

func main() {
	greeter := &service.GreetServer{}
	interceptors := connect.WithInterceptors(NewInterceptor())
	mux := http.NewServeMux()
	mux.Handle(greetv1connect.NewGreetServiceHandler(greeter, interceptors))
	corsHandler := cors.New(cors.Options{
		AllowedMethods: []string{
			http.MethodGet,
			http.MethodPost,
		},
		AllowedOrigins: []string{"*"},
		AllowedHeaders: []string{
			"Accept-Encoding",
			"Content-Encoding",
			"Content-Type",
			"Connect-Protocol-Version",
			"Connect-Timeout-Ms",
			"Connect-Accept-Encoding",  // Unused in web browsers, but added for future-proofing
			"Connect-Content-Encoding", // Unused in web browsers, but added for future-proofing
			"Grpc-Timeout",             // Used for gRPC-web
			"X-Grpc-Web",               // Used for gRPC-web
			"X-User-Agent",             // Used for gRPC-web
		},
		ExposedHeaders: []string{
			"Content-Encoding",         // Unused in web browsers, but added for future-proofing
			"Connect-Content-Encoding", // Unused in web browsers, but added for future-proofing
			"Grpc-Status",              // Required for gRPC-web
			"Grpc-Message",             // Required for gRPC-web
		},
	})
	handler := corsHandler.Handler(mux)
	http.ListenAndServe(":8080", handler)
}

func NewInterceptor() connect.UnaryInterceptorFunc {
	interceptor := func(next connect.UnaryFunc) connect.UnaryFunc {
		return connect.UnaryFunc(func(
			ctx context.Context,
			req connect.AnyRequest,
		) (connect.AnyResponse, error) {
			log.Println("test interceptor")
			return next(ctx, req)
		})
	}
	return connect.UnaryInterceptorFunc(interceptor)
}
